■  JAVA
** JAVA의 특징
    Java 응용 프로그램은 컴퓨터 아키텍처에 관계없이 모든 Java 가상 머신 (JVM)에서 실행할 수 있다.(플랫폼 독립적)
    바이트 코드(클래스 파일)로 컴파일된다.
    클래스기반 객체지향 프로그래밍
    광범위하게 응용프로그램에서 웹프로그램까지 사용되어 지고 있다.


** 프로그램 작성(SCJP 문제 수준)
   1) 1~100 까지 합구하기
   2) 별 찍기
   3) JBDC를 이용한 Insert
   4) 삼항 연산자
      변수 = 조건 ? 참일때_값 : 거짓일때_값;
   
** JDK 버전 및 차이
   1) 1.4 -> 5.0
      확장 for문,  Varagrs(비정형 인자 : ...),  제네릭(Generics), 오토박싱(Autoboxing : 기본자료형->객체로자동변환(Integer, Float등)), 언박싱(Auto-unboxing : 객체에서 기본 자료 형 자동변환), enum(열거형), Formatter(출력형식 지정 : format() 메소드, printf() 메소드등), 어노테이션(Annotation), StringBuilder 클래스 , Assertions, Static Import , goto문이 없어짐 등

   2) 5.0 -> 6.0
     - 인터페이스의 메소드를 재정의 할때 @Override 어노테이션 사용 가능
     - 국제화 지원 
     - File 클래스에는 디스크 공간을 알 수 있는 메소드 3개(getTotalSpace(), getFreeSpace(), getUsableSpace())가 추가되어서 디스크 사용량을 더 쉽게 체크할 수 있게 됨
     - 파일의 읽기, 쓰기, 실행 권한을 직접 세팅하고 읽어올 수 있게 되었다.
     - isFile() 메소드의 경우 Windows 에서는 CON, NUL, AUX, LPT 과 같은 장치 예약어와 같은 이름의 파일을 만드는 경우 이전에는 true 를 리턴했었지만 false 를 리턴하도록 수정되었다.
     - IO와 관련해서는 문자기반 콘솔을 사용하기 위해 java.io.Console 클래스를 추가하였다. 이 클래스에는 readPassword() 라는 메소드가 있어서 텍스트 기반의 간단한 애플리케이션에서도 보안을 신경써야 할 텍스트를 받을 필요가 있을 때 간단하게 사용할 수 있다. 
     - IOException 은 생성자에 Throwable 을 파라미터로 쓸 수 있게 되어서 exception chaining 이 가능하게 되었다. 
     - java.net.NetworkInterface 의 getHardwareAddress() 로 MAC 어드레스를 JNI나 다른 복잡한 방법을 사용하지 않고도 가져올 수 있다.
     - 추가된 컬렉션 API 인터페이스 : Deque, BlockingDeque, NavigableSet, NavigableMap
     - 추가된 컬렉션 API 클래스 :  ArrayDeque, LinkedBlockingDeque, ConcurrentSkipListSet, ConcurrentSkipListMap,  AbstractMap.SimpleEntry , AbstractMap.SimpleImmutableEntry
     - 업데이트 된 컬렉션 API 클래스 : LinkedList, TreeSet, TreeMap, Collections


** Overloading(메소드 중복정의) 과 Overriding(메소드 재정의)
    - Overloading : 메소드가 처리하는 기능은 같고 메소드 괄호 속에 오는 인수의 개수가 다르거나 자료 형(type)이 다른 경우, 메소드의 이름을 동일한 이름으로 부여하여 메소드를 정의 할 수 있는데 이를 메소드 오버로딩(Method Overloading)라 한다.
    - Overriding : 상위 클래스를 상속 받은 하위 클래스에서 상위 클래스에 정의된 메소드를 재정의 하는 것으로 객체 지향 프로그램의 특징인 다형성(Polymorphism) 을 나타낸다. 재정의(overriding)는 반드시 상속 관계가 있어야 하며 메소드의 이름, 리턴 타입, 매개 변수의 수나 타입이 완전히 일치해야 한다.


**  객체(object) 
    효율적으로 정보를 관리하기 위하여 사람들이 의미를 부여하고 분류하는 논리적인 단위이다. 프로그래밍에서는 클래스에 정의된 내용대로 메모리에 생성된 것을 말함.


**  클래스
    클래스(class)란 어떤 특정 종류의 모든 객체(object)들에 대해 일반적으로 적용할 수 있는 멤버 변수와 메소드를 정의한 소프트웨어적인 설계도(blueprint) 또는 프로토타입(prototype)이라 할 수 있다. 즉, 실세계에 존재하는 객체들이 가질 수 있는 상태와 행동들에 대해 소프트웨어적으로 추상화(abstraction) 해 놓은 것이 클래스(class)이다.

 
** 객체와 인스턴스
   클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화 라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 함.


** 객체 지향 프로그래밍(Object-Oriented Programming, OOP)
    컴퓨터 프로그래밍의 패러다임의 하나이다. 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있음.

    - 캡슐화(Encapsulation) : 하나의 문제를 해결하기 위한 데이터와 메서드를 하나의 단위로 묶는다는 것으로서, 클래스의 내부 정의에 대해 외부에서 볼 수 없도록 하는 것이 특징(은닉화).
    - 추상화(Abstraction) : 모델(Object)의 자세한 성질을 무시하고(숨기고) 그들의 일	반적인 성질을 나타낸다는 것으로서, 일반적으로 클래스는 클래스로 표현할 서브클래스(또는 객체)의 공통적인 성질과 행위를 일반화하여 디자인 되게 되며 그로부터 생성된 객체는 자신의 고유의 성질을 가지게 됨.
    - 다형성(Polymorphism) : 다형성이란 같은 메시지에 대해 클래스에 따라 다른 행위를 하게 되는 특징. 일반적으로 같은 이름을 가지는 메서드에 대해 인자(Argument)의 개수와 데이터 형(Data Type)에 따라 수행되는 행위가 달라짐을 의미. 다형성을 통해서 사용자는 약속된 인터페이스를 따르는 서로 다른 객체를 같은 방식으로 사용 할 수 있게 됨.
    - 상속(inheritance) : 기존에 있던 클래스를 바탕으로(즉, 기존의 클래스로부터 상속받음) 다른 특성을 추가해 새로운 클래스를 만들 수 있음.


** 자바언어와 기존의 언어와의 다른 특징
   - 포인터를 사용하지 않는다. (포인터는 존재, 연산을 허용하지 않음)
   - 자동으로 garbage collection 기능을 수행한다.
   - 엄격한 형 검사(strict type checking)를 수행하여 에러를 조기에 발견한다.
   - 실행시간에 발생하는 에러를 처리한다.


** 예외처리의 필요성과 목적
   - 예외는 프로그램 실행 중에 발생할 수 있는 명령어의 정상적인 흐름을 방해하는 이벤트로 자바에서 예외는 하나의 오브젝트 이다. 프로그램 실행 중에 메소드 안에서 에러가 발생할 경우, 메소드는 그 에러에 해당하는 예외 오브젝트를 만들고 그것을 자바 런 타임 시스템(runtime system)에 전해준다.
  -  예외를 사용하여 에러 처리 시 장점
     일반적으로 프로그램의 실행 코드와 에러를 처리하는 코드를 분류할 수 있다.
     메소드의 콜 스택(Call Stack)에 에러를 차례대로 보낼 수 있다.
     에러 타입을 종류별로 분류할 수 있다.


** abstract 클래스
  - abstract 클래스(추상 클래스)는 선언만 있고 정의가 없는 하나 이상의 추상 메소드를 갖는 클래스로 하위 클래스에서 오버라이딩(overriding) 할 것으로 예상되는 메소드에 대해 메모리 낭비 없이 미리 호출 계획을 세워 두기 위해 만든다.
  - new로 객체를 생성할 수 없다.  
  - 상속받은 클래스는 추상 메소드를 구현해야만 인스턴스를 생성할 수 있음.
  - 추상 메소드란 함수의 리턴타입과 파라메터만 있고 정의부분의 없는 메소드를 말함.

** 추상화
  - 구체적인 개념으로부터 공통된 부분들만 추려내어 일반화 할 수 있도록 하는 것을 의미. 일반적으로 사용할 수 있는 단계가 아닌 아직 미완성적 개념.


** interface
  - 인터페이스(interface)란 완전히 미완성된 채로 남겨진, 즉 인터페이스(interface)안의 어떤 메소드(method)도 메소드 몸체가 존재하지 않아 실행 부분이 존재하지 않는 클래스를 위한 템플릿으로서의 기능을 수행하는 추상 클래스의 한 종류이다.
  - 모든 변수는 static이고 final임.
  - 인터페이스는 다중 상속이 가능함.
  - 장점
    개발시간을 단축시킬 수 있다.
    표준화가 가능하다.
    서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
    독립적인 프로그래밍이 가능하다.


** 추상클래스와 인터페이스의 공통점
  - 객체를 발생시킬 수 없음.
  - 상속해서 하위 class를 통하여 객체를 발생시킴.(메소드를 재정의 해야 함.)


** 변수이름 정하는 규칙
 - 클래스 : 첫 문자는 대문자로 시작. 둘 이상의 단어가 묶어 구성할 때는 새로 시작하는 단어는 대문자로 함.
 - 메소드 : 첫 문자는 소문자로 시작. 둘 이상의 단어가 묶어 구성할 때는 새로 시작하는 단어는 대문자로 함.
 - 상수 : 모든 문자를 대문자로 구성. 둘 이상의 단어가 연결될 경우는 _(언더바)를 사용하여 연결 함.


** JVM의 구성
  - 메소드 영역(Method area)
    메소드와 클래스 변수를 저장하기 위한 공간
    모든 프로그램에 의해 공유
  - 힙 영역(Heap area)
    동적으로 할당하여 사용할 수 있는 메모리 공간
    주로 실행시간에 생성되는 객체를 저장
  - 스택 영역(Stack area)
    메소드 호출 시 메소드의 매개변수, 지역변수, 임시변수 등을 저장하기 위한 스택 구조의 메모리
    실행중인 프로그램에 따라 스택 프레임 할당
  -  PC 레지스터
     JVM이 현재 수행할 명령어의 주소를 저장
  - Native 메소드 스택
    native() 메소드를 호출할 때 native() 메소드의 매개변수, 지역변수 등을 저장


** Collection에서 데이터를 저장 하는 3가지와 그 특징
  - Set : 순서가 없고, 중복을 허용하지 않는 자료구조
  - List : 순서지정이 가능한 요소들의 집합으로 ArrayList, LinkedList, Vector를 포함한 여러 클래스에서 List interface가 구현되어있다.
             배열과 같은 구조지만, 가변적 길이를 가지고 있다. Set 과는 다르게 중복하는 요소를 추가 할 수 있다.
  - Map : key 값과 value값의 형식으로 저장되면 key 값은 절대 중복이 안 됨.(중복적인 키를 삽입하는 이전의 데이터를 덮어 씀),  Iterator가 없다.


** String, StringBuffer, StringBuilder의 차이점
  - String 클래스 : 상수문자열, final 클래스이므로 상속시킬 수 없으며, 내부 문자열 데이터도 수정이 불가능하다.
  - StringBuffer 클래스 : 문자열을 사용할 때 문자열을 실행시간에 변경할 수 있다. 즉,  StringBuffer 객체는 가변적인 길이를 가지므로 객체를 생성하는 시점에서 미리 그 크기나 값을 지정하거나 실행 시간에 버퍼의 크기를 바꿀 수 있는 기능을 제공한다.
  - StringBuilder 클래스 : StringBuilder는 Java5 에 추가된 클래스로 StringBuffer와 기능이 같다.
  - 차이점 : StringBuffer은 동기화(synchronized)되지만 StringBuilder는 그렇지 않다.  
     즉, StringBuilder은 다중 thread에서는 안전하지 않으므로 동기화가 필요한 경우에는 StringBuffe은 사용하는 것이 좋다.


** 스트림이 무엇이며 스트림의 특징은?
  - 스트림 : 데이터를 목적지로 입 · 출력하기 위한 방법. 스트림에 데이터를 쓸 수 있고, 데이터를 읽을 수 있음. 연결하고자 하는 Device에 따라 다양한 스트림이 존재.
  - 특징 : 스트림은 FIFO 구조.  읽기, 쓰기가 동시에 되지 않음.  읽기, 쓰기가 필요하다면 읽는 스트림과 쓰는 스트림을 각각 하나씩 열어 사용해야함. 데이터가 처리 되기 전까지 스트림에 사용되는 스레드는 데이터가 모두 전송되기 전까지 블록킹 상태에 빠짐. 


** 동기화
  - 여러 스레드가 동시에 실행될 때 2개 이상의 스레드가 동일한 데이터에 접근하여 작업 시 문제점이 발생할 수 있는데, 이런 문제점을 해결하기 위한 방안이 동기화이다.
  - 여러 명이 접근 하는 것을 막기 위해 모든 객체에 락을 포함 시키는데, 락이란 공유 객체에 여러 스레드가 동시에 접근하지 못하도록 하기 위한 것으로 모든 객체가 힙 영역에 생성될 때 자동으로 만들어 짐.
  - synchronized 메소드, synchronized 블럭


** InnerClass 를 쓰는 이유
  - 내부 클래스를 사용하면 같은 패키지에 있는 다른 클래스한테 까지도 숨길 수 있기 때문에 outer class를 통하지 않고서는 접근할 수 없음. 보안성이 좋아짐.


** Statement 와 PreparedStatement의 차이
  Statement의 execute() 메소드는 문자열 된 SQL 문을 DBMS로 전달하는 역할을 수행하며, 내부적으로는 SQL 문을 JDBC 드라이버가 읽어들 일 수 있는 형식으로 전처리(Precompile)한다. 이후 드라이버는 DBMS에 전 처리 된 요구 사항을 보내게 되는데, SQL 문을 매번 전 처리 해야 하기 때문에 반복적인 작업에서 속도가 느려질 수 있다.
  하지만 PreparedStatement는 전 처리된 Statement로 주어진 SQL 문을 미리 전처리 과정을 해둔 상태로 보관하기 때문에 반복 작업에 유리하다.

  - Statement : 정적 쿼리 시 사용. 매번 파싱과정을 거쳐야 함.(부하가 생길 수 있음) SQL문 전체를 명확히 알 수 가 있어서 디버깅이 쉬움.
  - PreparedStatement : 동적 쿼리 시 사용. 한번 파싱하면 그 동일한 SQL문장을 곧바로 파싱 과정 없이 Execution 할 수 있음.(반복적인 다량의 SQL 수행 시 성능 상 이득이 있음) 오류발생 시, 변수에 입력되는 값을 알 수 없어서 디버깅이 어려움.


** 더블버퍼링을 사용하는 이유
  - 이미지를 출력 시키는 경우 화면을 지웠다가 다시 그리게 되면 깜박거리게 됨. 이러한 문제점을 해결하기 위해, 화면에 직접 이미지를 그리지 않고 메모리상에 미리 그려놓고 필요할 때 한번만 화면에 출력 시키는 방법으로 출력 시 깜박거림을 최소화 시켜줌.


** AWT와 Swing의 차이점
  - AWT : flatform에 종속. 중량 Component. Frame 자체에 분할. 범용 Component.
  - Swing : flatform에 자유로움. 경량 Component. Frame 포함 멤버 분할. Local Component.
  - 스윙 컴포넌트들은 자바가 직접 각 컴포넌트들을 렌더링하고 기능을 구현하는 새로운 기술인 경량(lightweight) 컴포넌트 기법을 적용하여 만든 컴포넌트들로 기반 운영 체제의 윈도우 시스템에 대응하는 컴포넌트가 있을 필요가 없어, 편리하고 다양한 사용자 인터페이스를 제공할 수 있다.


** 자바 빈즈 란?
  - 자바에서 사용하는 컴포넌트. Bean은 자바에서 컴포넌트를 이용하기?위해 만들어 놓은 기술. 컴포넌트를 사용하면 좋은 이유는 필요 할 때마다 가져다가 사용 할 수 있다는 점인데, JSP에서 자바의 컴포넌트를 이용해서 프로그래밍 하는 것을 빈즈 프로래밍이라 함.


** Connection Pool 개념
  - 미리 생성해 놓은 커넥션을 할당하고 반납함으로써 커넥션 생성 시간을 줄인다는 개념. 미리 생성할 때 너무 조금 생성하면 오히려 타임오버헤드가 늘어나고, 반대로 너무 많이 생성하면 메모리 오버헤드가 늘어남.


** Design Patterns
  패턴이란 객체들 간의 일반적인 상호 작용들을 모델로 정의한 것으로 특정 컨텍스트(패턴이 적용되는 상황. 반복적으로 일어날 수 있는 상황) 내에서 주어진 문제(해당 컨텍스트 내에서 이루고자 하는 목적 또는 제약조건)에 대한 해결책(일련의 제약조건 내에서 목적을 달성할 수 있는 일반적인 디자인)이다.


** Singleton
 -  싱글턴 패턴은 해당 클래스의 인스턴스가 하나만 만들어지고, 어디서든지 그 인스턴스에 접근할 수 있도록 하기 위한 패턴이다.
 -  프로그램 상에서 두 번째 인스턴스 를 만들 수 없게 한다(생성자를 private 으로 작성)
 - 예
   public class DBConn {
	private static Connection conn = null;

	private DBConn() {
	}
	
	public static Connection getConnection() {
                     :		
		return conn;
	}


** OOL
  - Object Oriented Language, 객체지향 언어.


** OOP
  - Object Oriented Programming, 객체지향 프로그램.


■  WAS (Web Application Server)
1. WAS : Web Application Server의 약자.
   - 서버와 클라이언트 사이에 있는 3-tier 방식으로서, Server가 처리하는 양이 많아지면서 Server에 생기는 부하를 해결하기 위해 개발 됨.
   - Client에서 요청이 들어오면 실제적인 처리는 WAS가 하고 서버는 단지 Client에 결과 값을 뿌려주는 역할만 하게 됨.

2. 대표적인 제품 : 톰캣, 웹스피어, 웹로직, 제우스등.	


■  미들웨어
   Middleware, 최근 네트웍 상호 호환과 연동상태를 관리하는 분산 환경에 관심을 갖고 데이터베이스, 스프레드쉬트, 윈도우 OLE등 다양한 소프트웨어를 다루는 데 더 관심을 갖음. 이러한 공통의 인터페이스를 준수하는 컴포넌트 기반의 소프트웨어는 많은 장점을 제공함. 


■ Servlet/JSP
1. 서블릿(Servlet)
  - 자바를 사용하여 웹페이지를 동적으로 생성하는 서버 측 프로그램.
  - 서버용 애플릿, 웹서버에서 실행되는 작은 자바 코드. JVM에서 실행되므로 플랫폼의 구애를 받지 않고, 웹서버와 충돌이 없고 메모리 관리가 철저함. 
  - 웹브라우저에서 실행되지 않고 GUI로 구성되지 않는다는 점이 애플릿과 다름. 
  - 웹서버에서 실행되는 서블릿 엔진과 서비스 요청 및 이에 대한 반응 형태로 사용. 


2. 서블릿에서 데이터를 처리 하는 방식에는 무엇이 있으며 그 특징은?
  - GET : 서버에 있는 정보를 가져오기 위해 설계 됨. 240바이트까지 전달 할 수 있음. POST 방식에 비해 속도가 빠름. URL노출로 보안성이 요구되는 경우엔 사용 할 수 없음. 검색엔진에서 검색단어 전송에 많이 이용함.
  - POST : 서버로 정보를 올리기 위해 설계 됨. 데이터크기의 제한이 없음. GET 방식에 비해 속도가 느림. URL에 파라미터가 표시 되지 않음. 내부적으로 데이터가 이동함.

	
3. 포워딩과 리다이렉트
  - 포워딩 (Forwarding)
    요청을 포워딩할 때 해당 요청은 서버의 다른 자원(서블릿 또는 JSP) 에 전달된다. 이때에는 다른 자원에서 이 요청을 처리할 것을 클라이언트에 알리지 않는다. 이런 방식의 처리는 웹 컨테이너 안에서만 일어나고, 클라이언트는 알 수 없게 된다. 포워딩은 리다이렉트와는 다르게 객체를 요청에 담고, 해당 요청을 사용할 다음 자원에 전송한다.
  따라서 클라이언트는 포워딩이 발생한 사실을 알지 못한다. 포워딩은 클라이언트와 통신 없이 서버에서만 처리되기 때문에 리다이렉트보다 나은 성능을 보여준다.

  - 리다이렉트 (Redirect)
    클라이언트의 요청을 처리 한 후, 컨테이너는 sendRedirect() 메소드가 호출되면 브라우저에 응답을 보낸다. 이 응답에는 브라우저가 웹 컨테이너의 응답을 받은 후 다시 요청을 보낼 새로운 URL 을 포함한다. 여기에서 하나의 요청이 종결된다. 새로 부여받은 URL 로 브라우저에서 완전히 새롭게 요청하기 때문에 이전의 요청 스코프에 저장되어 있는 객체는 새로운 요청 전에 소멸된다.
  리다이렉트는 추가적으로 발생한 왕복 처리 때문에 포워딩보다 느리다. 기억해야 할 것은 최종적으로 수행하는 작업은 새로운 요청에 의한 것이고, 이것을 클라이언트가 알고 있기 때문에 브라우저 창의 주소가 처음 요청한 주소가 아니고 최종 주소 값으로 변한다. 또한 하나의 요청에 담겨있던 객체들은 소멸되어 다음 작업까지 전달되지 않는다.


4. Cookie 와 Session 의 차이
  - Cookie : 클라이언트에 정보를 저장하기 때문에 서버에 부하가 없음. 유효시간을 설정 할 수 있음.
  - Session : 서버에 정보를 저장하기 때문에 서버에 부하가 많이 생김. 해당 클라이언트와 일정시간동안 작용이 없으면 서버메모리에서 해제 됨. 직접적으로 해제 시킬 수 있는 method가 있음.	


5. JSP 와 자바스크립트의 차이
  - JSP는 자바에서 파생된 서버스크립트 이며, 서버사이드 스크립트로서 웹 페이지를 작성하는데 사용.
  - 자바스크립트는 클라이언트사이드 스크립트 이며, 브라우저의 객체를 제어하는데 쓰임.


6. 서블릿의 실행 과정
  - 서버가 클라이언트의 연결 요청을 받음.
  - 웹 컨테이너는 연결 요청 정보를 담고 있는 Request 객체와 연결 응답 정보를 담고있는 Response 객체를 생성.
  - 접수된 Url을 분석 후 해당 서블릿 객체를 생성하고, 사용자의 요청을 처리하기 위해 스레드를 생성 후 service() 메소드에 인자값을 담아 호출.
  - service() 메소드는 Request 객체를 참고하여 어떤 연결 요청 방식(GET 방식인지 POST 방식인지)으로 들어왔는지 파악 함.
  - 들어온 요청 방식에 따라 get 방식은 doGet() 메소드를 post 방식은 doPost() 메소드를 호출하여 처리 함.
  - service() 메소드의 인자값으로 넘겨받은 response 객체를 이용하여 클라이언트에게 결과를 보여줌.
  - 사용자 요청을 처리하기 위해 생성한 스레드를 소멸.


7. 서블릿 라이프 사이클(생명 주기)
  - Servlet은 javax.servlet.GenericServlet 클래스나 javax.servlet.HttpServlet 클래스를 상속받아서 작성하며, init(), service(), destory()의 세 개의 메서드에 의한 생명주기를 갖는다.
   서블릿이 로딩 될 때 단 한번 init() 메서드를 호출하게 되며 클라이언트의 요청이 있을 때마다 service() 메서드를 반복적으로 호출하게 된다. 서블릿 객체는 메모리를 해제하기 위해서 destroy() 메서드를 호출하게 된다.


8. JSP 라이프 사이클(생명 주기)
  - JSP 변환 서블릿 프로그램은 _jspInit(), _jspService(), _jspDestroy()의 세 가지 메서드에 의해서 초기화, 서비스, 파괴의 과정을 거친다. _jspInit() 메서드는 단 한번 호출하며 _jspService() 메서드는 서비스 요청이 있을 때마다 호출하게 된다. 즉, 클라이언트에서 JSP 문서를 클릭하게 되면 JSP 문서는 Servlet으로 변환되고, 그 변환된 Servlet에서 처음으로 _jspInit() 메서드가 호출된다. _jspInit() 메서드는 JSP 에서 변환된 Servlet의 초기화 및 서비스를 시작하기 위한 준비를 하는 메서드이다. 그리고 서블릿에서 init() 메서드가 service() 메서드를 호출하듯이 JSP의 _jspInit() 메서드는 _jspService() 메서드를 호출한다. 호출된 _jspService() 메서드는 클라이언트에서 요구한 작업을 수행하는 메서드이다.


9. JSP를 구동하기 위해 서버를 구축하는 과정
 - 자바 인스톨 :
    JDK 인스톨. 
    JRE 인스톨(JDK를 설치하면 설치가 되기 때문에 따로 설치할 필요는 없음)
 - 환경변수 setting : 컴퓨터의 환경변수 설정
 - 미들웨어 : JSP를 웹으로 변환 해줄 수 있는 톰캣 설치. 


10. JSP는 무엇이며 JSP의 특징
 - JSP란? : Java Servet Pages 의 약자로써 자바를 기반으로 하고 있는 스크립트 언어.
 - 특징 : 자바언어를 기반으로하는 스크립트 언어로써 자바의 장점을 사용 할 수 있음.
            자바언어를 기반으로 하고 있기 때문에 플랫폼에 상관없이 사용할 수 있음.
            표현언어, 표현식, 스크립틀릿 등의 다양한 스크립트 요소와 액션 태그등을 제공함으로써 보다 쉽게 웹 어플리케이션을 개발 할 수 있음.
            서블릿/EJB 등의 엔터프라이즈 기술들과 잘 융합됨.


11. request, response
  - request
    웹컨테이너(서블릿 컨테이너)가 클라이언트로부터 온 요청에 대한 정보를 서블릿(jsp)에게 전달하기 위해 사용하는 기능을 정의하고 있다.
    
  - response
    클라이언트 요청에 대한 응답을 MIME 자료 형태로 반환하는 데 사용
    즉, 웹 서버에서 웹 클라이언트(브라우저)에게 자료를 반환하는데 사용


■  XML은 무엇이며 XML의 특징
  - XML이란? : 사용자 정의 태그를 통해 텍스트 데이터의 구조화된 문서 저장과 application 간의 문서 교환을 위해 1986년 ISO에 제안된 마크업 언어. SGML의 일부 기능과 인터넷에서 이용하기 쉬운 HTML의 장점을 도입하여 개발한 언어.
  - 특징 : 사용자 정의 태그가 가능하며, 텍스트 데이터를 구조화하고 전송할 목적(텍스트 데이터의 재사용과 정보 검색 용이) Application and WebApplication 모두 사용 가능


■ JAVA Framework
1. Framework
 - 특정 형태의 소프트웨어 문제를 해결하기 위해, 상호 협력하는 클래스들과 인터페이스의  집합.
 - 장점 : 재사용성, 단순성, 역할구분, 확장성, 유지보수용이.
 - 프레임웍과 라이브러리 차이
   라이브러리는 어플리케이션에서 호출할 수 있는 함수와 루틴으로 구성되어 있음.
   프레임워크는 어플리케이션에서 특정 기능들을 제공하기 위해 확장할 수 있는 일반적이고 상호 협력적인 컴포넌트를 제공.

2. MVC 패턴이란 ?
  - Model, View, Control의 역할을 확실하게 분리시켜놓는 프로그래밍 기법. 
    MVC란 중간에 Controller 컴포넌트를 두어 비즈니스 로직과 데이터 접근 로직, 프리젠테이션 로직을 분리시킨 디자인 패턴이다. 각 영역별로 역할이 명확히 구분되므로 모듈 간의 의존성을 낮추어 재사용성 및 확장이 용이한 구조이기 때문에 유지보수에 유리하다. 모델 1이 JSP에 프리젠테이션 로직과 비즈니스 로직, 데이터 접근 로직이 함께 들어갔던 반면 모델2는 각각의 역할을 나누어 작업을 분담시킨 MVC 패턴을 웹에 적용한 것이다. View를 담당하는 JSP는 프리젠테이션 로직만을 처리하고 Controller는 요청을 어디로 보낼지 결정한다. 그리고 Model은 비지니스 레이어에 포함된다.


3. Model 1 방식 과 Model 2 방식의 특징과 차이점
 1) Model 1 
    디자인 코드와 자바 코드(비즈니스로직)를 구분하지 않고, 하나의 JSP 일 내에 기술해서 웹 프로그램을 제작 하는 방식.
    - Model 1 특징 :
      * 개발하기가 쉽고, 배우기가 쉬움.
      * 디자인코드와 비즈니스로직의 구분이 명확하지 않아, 복잡도가 높음.
      * 수정 시 디자이너와 개발자의 협업이 필요.
      * 비즈니스로직의 재 사용성이 어려우며, 유지 보수가 힘듬. 

 2) Model 2 
   웹 어플리케이션을 개발할 때, MVC패턴을 적용하여, 웹 어플리케이션의 개발이 가능하도록 구현한 것.
   - Model 2 특징 :
     * 초기 설계에 많은 시간이 소요.
     * 디자인코드와 비즈니스로직이 분리되며, 비즈니스로직의 재사용성이 높아짐.
     * 비즈니스로직 계층의 확장성이 용이하며, 유지보수가 편하다. 


4. Struts2
 - Struts2 : MVC패턴을 지원하고, 웹 어플리케이션을 개발하기 위한 프레임워크.	
 - 특징 : Struts1 + Webwork2의 아키텍처 적용.
            POJO(Plain Old Java Object) 기반 액션 사용.
            Zero configration(설정 없이) 지향.
            Ajax기능을 태그와 테마 기반으로 구성.
            다양한 표현식 언어 사용 가능(JSTL, OGNL).	
 - MVC 모델에서 커버하는 부분 : Controller 지원.
 - 실행 순서(실행구조) :
    web.xml의 등록된 FilterDispatcher를 통해서 요청에 대해 진입.
    FilterDispatcher 에선 모든 요청을 처리하고, ActionPloxy 생성.
    ActionPloxy가 생성되면, FilterDispatcher가 실행 권한을 이임.
    Configuration은 struts.xml을 통해서 설정관리자를 초기화함.
    초기화 후, Action invocation 실행.
    실행할 Interceptor가 있으면 실행 하고, Action으로 전달.
    Action에서 결과 값을 통해, 해당 Template으로 이동.
    Interceptor자원 반납 후 응답.


5. Spring
 1) 개요
   - Spring : Java Enterprise Application 개발에 사용 되는 Application Framework. 개발을 빠르고 효율적으로 할 수 있도록 Application의 바탕이 되는 틀과 공통프로그래밍 모델, 기술 API를 제공.
   - 특징 :  스프링은 종속객체주입이라는 기술을 통해 낮은 결합도를 유지할 수 있음.
               AOP를 이용하여 객체지향만이 아닌 관심지향 기법을 활용.
               EJB 기능을 대체 할 수 있음. 트랜젝션 처리를 위한 일관된 방법을 제공.
               레이어간 연결이 interface로 이루어지기 때문에 interface 생성이 필요.
               다양한 프레임워크와의 통합.
  - MVC 모델에서 커버하는 부분 : Controller 지원.
  - 실행 순서(실행구조) :
    web.xml의 등록된 DispatcherServlet를 통해서 요청에 대해 진입.
    DispatcherServlet은 Client로부터 들어온 URL을 HandlerMapping 라는 곳으로 전송 후 URL을 분석해서 알맞은 Controller 이름을 다시 DispatcherServlet으로 보냄.
    HandlerMapping이라는 것을 통해서 실행될 Controller의 이름을 입력받은 DispatcherServlet은 전달받은 Controller를 실행시킴. 이렇게 실행된 Controller는 스프링에서 제공하는 ModelAndView 객체에 뷰 페이지에 전달할 객체와 View Page 이름 정보를 담고 DispatcherServlet으로 보냄.
    ViewResolver를 통해 보여 질 View페이지를 탐색한 후 View페이지를 보여줌.
	
 2) DI 와 AOP의 대해 설명하시오.
   - DI : Dependency Injection의 약자 의존성 주입이란 뜻. 스프링을 적용하여 applicationContext.xml에서 설정만 해주면, 외부 설정파일(xml)에서 연관관계에 있는 객체를 주입해주기 때문에 의존객체를 찾기 위한 코드가 필요하지 않게 됨. 즉, 외부설정에서 객체를 찾아서 쓰기 때문에 코드 내에 의존관계를 맺는 코드 생성이 불필요.
  - AOP : Aspect oriented programming의 약자 관심지향 프로그래밍.
    프로그래밍을 할 때 특정한 관심사를 가진 코드 부분을 별도의 모듈로 분리함으로써, 기존 객체지향의 강력한 기능(상속, 위임)만으로는 처치가 곤란했던 중복을 제거 할 수 있게 됨.
    예를 들어 로깅과 같은 기본적인 기능이나, 트랜잭션, 보안등 어플리케이션 전반에 걸쳐 적용되는 공통 기능들은 어떤 특정 모듈에 한정적으로 필요한것이 아니라 어플리케이션 전반에 걸쳐 필요한 기능으로 핵심 비즈니스 로직과는 구분되며, 핵심 비즈니스 기능과 구분하기 위해 공통 기능을 공통 관심 사항(cross-cutting concern)이라고 표현하고, 핵심 로직을 핵심 관심 사항(core concern)이라고 표현 한다.


6. Struts와 Spring MVC의 차이점
    - 두 Web Framework 모두 Controller를 사용하는 MVC2 모델을 따르고 있지만, Spring MVC는 Spring내에 포함되어져 있는 기능으로 Spring에 최적화 되어 있는데 일례로, Spring의 기본 개념인 Injection 기법을 이용하여 비즈니스 오브젝트에 손쉽게 접근할 수 있다. Struts와의 큰 차이로는 Form 객체 대신 Value Object를 사용한다는 점에 있다.


7. iBatis(mybatis)
  - mybatis(IBATIS)는 퍼시스턴스(Persistence) 계층(데이터 처리 계층)의 프레임워크로 다른 객체 관계 매핑 프레임워크들과는 달리 정형화된 테이블 구조에 의존하지 않고 SQL 구문의 실행 결과에 객체를 매핑 하는 방식으로 테이블 구조가 복잡해지고 정규화 돼 있지 않더라도 테이블을 변경할 필요 없이 기존 개발 방법에서 사용한 SQL을 그대로 사용할 수가 있으며, SQL에 적용한 튜닝들도 모두 그대로 유지된다.
  - SQLMaps는 엄밀하게 말하면, 자바 빈즈를 PreparedStatement 파라미터와 ResultSet으로 매핑 시켜주는 기능을 담당한다.
  - Java에서 DataBase를 편하게 Handling 할 수 있게 해주는 프레임 워크.
  - 특징 : SQL문과 Java코드와의 분리 만으로도 Java개발자는 Query문을 신경쓰지 않아도 됨. SQL문이 변경되더라도 파라미터 값만 변경 되지 않는 다면 Java소스에서 수정할 부분이 없기 때문.
  - MVC 모델에서 커버하는 부분 : Model 지원.
  - 실행 순서(실행구조) :
    자바 코드 내에서 특정 쿼리문을 실행하기 원할 때, 파라미터와 필요한 조건을 넘기기 위한 객체를 생성.
    SQLMaps를 실행하기 위해 쿼리의 객체와 이름을 넘겨줌.
    쿼리가 실행되었을 때 SQLMaps는 쿼리 결과를 받기 위해 정의 된 클래스의 인스턴스를 생성하게 됨.
    인스턴스는 데이터베이스에 의해 반환 된 ResultSet 으로부터 만들어짐.


■  Oracle
1. 자료 추가
   INSERT 테이블명 INTO (필드명, 필드명, ...) VALUES (값, 값, ...)

2. 자료 수정
   UPDATE 테이블명 SET 필드=값, 필드=값 WHERE 조건

3. 자료 삭재
   DELETE FROM 테이블명 WHERE 조건

4. 자료 출력
   SELECT 필드명, 필드명 FROM 테이블명 WHERE 조건

5. JOIN
   1) EQUI JOIN(조건에 만족하는 자료만 추출)
       SELECT 테이블_명1.컬럼_명, 테이블_명2.컬럼_명 FROM 테이블_명1, 테이블_명1
         WHERE 테이블_명1.컬럼_명1=테이블_명2.컬럼_명1

        또는

       SELECT 테이블_명1.컬럼_명, 테이블_명2.컬럼_명 FROM 테이블_명1
         JOIN 테이블_명2 ON 테이블_명1.컬럼_명1=테이블_명2.컬럼_명1

   2) OUTER JOIN(JOIN 조건을 만족하지 않는 행을 보기 위한 추가적인 join의 형태)
      (1) LEFT OUTER JOIN(조건에 만족하지 않은 왼쪽 자료를 모두 출력하고 오른쪽은 만족하는 자료만 출력)
          SELECT 테이블1명.컬럼명, 테이블2명.컬럼명
                 FROM 테이블1명
                      LEFT OUTER JOIN 테이블2명
                      ON 테이블1명.컬럼명=테이블2명.컬럼명

      (2) RIGHT OUTER JOIN
          SELECT 테이블1명.컬럼명, 테이블2명.컬럼명
                 FROM 테이블1명
                      RIGHT OUTER JOIN 테이블2명
                      ON 테이블1명.컬럼명=테이블2명.컬럼명

6.  TRIGGER
    - 트리거란 DML 작업 즉, insert, delete, update 작업이 일어날 때 자동으로 실행되는 객체로 특히 이런 트리거를 DML 트리거라 한다. 트리거는 데이터의 무결성 뿐만 아니라 자동으로 파생된 열 값 생성, 잘못된 트랜잭션 방지, 복잡한 보안 권한 강제 수행 등을 수행 한다.


7. PROCEDURE
    - PL/SQL에서 가장 대표적인 구조인 스토어드 프로시저는 개발자가 자주 실행해야 하는 업무 흐름을 미리 작성하여 데이터베이스 내에 저장해 두었다가 필요할 때마다 호출하여 실행할 수 있다.


8. CURSOR
    - 오라클에서는 하나의 레코드가 아닌 여러 레코드로 구성된 작업영역에서 SQL문을 실행하고 그 과정에 생긴 정보를 저장하기 위해서 CURSOR를 사용하며, 커서에는 암시적 커서와 명시적 커서가 있다.
      암시적 커서는 모든 SQL 문에 기본적으로 존재하며, SQL 문 실행 후 오직 하나의 row만 출력하게 된다. 그러나 SQL 문 실행한 결과물(result set)이 여러 row로 된 경우 CURSOR를 명시적으로 선언하여야 여러 row를 다룰 수 있다.
      또한 커서는 Private SQL의 작업영역 으로 오라클 서버에 의해 실행되는 모든 SQL문은 연관된 각각의 커서를 소유하고 있다.


9. Index
① 인덱스를 사용하는 이유
   - 인덱스를 만드는 이유는 가장 큰 이유가 데이터를 빠르게 검색하기 위함입니다
   - 인덱스를 만드는 두번째 이유는 Row의 유일성을 유지하기 위한 것입니다
② 인덱스 사용 시 단점
   - 인덱스를 만들게 되면 그 정보를 유지하기 위해서 디스크 공간도 필요하게 되고, 인덱스가 걸려 있는 테이블은 인덱스가 없을 때보다 데이터를 추가하거나 변경할 때 많은 시간이 소요 됩니다
③ 인덱스의 종류
   - Unique Clustered Index                - Nonunique Clustered Index
   - Unique Nonclustered Index           - Nonunique Nonclustered Index
④ 클러스터드 인덱스는
   - 한 테이블에 단 한개만 존재할 수 있습니다.
   - 범위(Range)를 주어 검색 할 때 탁원한 기능을 발휘합니다.
   예) 키순으로 서세요, 나이순으로 서세요. 이름순으로 서세요
⑤ 넌클러스터드 인덱스(Nonclustered Index)는
   - 한 테이블에 여러개 존재할 수 있습니다.
   - 특정한 값으로 찾아갈 때(Seek) 탁월한 성능을 발휘합니다.
   예) 도서명, 저자명, 분야명


10. 트랜젝션, 롤백, 커밋
 ① 트랜젝션 : 일련의 작업단위로 특성으로 ACID(원자성,일관성,고립성,영구성)가 있음.
 ② 트랜젝션의 필요성 : 여러작업이 한 자원에 동시에 변경, 참조가 필요한 경우, 작업공정이 긴 경우.
 ③ 트랜젝션의 시작 : 
   - 첫 DML(데이터조작어)구문이 실행될 때.(SELECT에선 제외)
   - 사용자가 SAVEPOINT를 설정할 때.
 ④ 트랜젝션의 종료 : 
   - commit 수행.   ☞ rollback 수행.
   - DDL(데이터정의어), DCL(데이터제어어)이 실행될 때. 
   - 오라클 내부에서 자동 commit 수정.
   - 사용자가 sqlplus를 종료할 때, 시스템 크래쉬 발생.
 ⑤ 커밋과 롤백 전
   - 롤백으로 데이터 회복가능.
   - 현재 유저는 자신이 바꾼 데이터를 확인할 수 있다.
   - 다른 유저에게는 바뀐 데이터 내용이 반영되지 않음.
   - 영향을 받은 레코드는 잠금 상태.
 ⑥ 커밋 후
   - 데이터는 영구적으로 변경.
   - 복구 불가능.
   - 모든 유저에게 변경 내용이 반영.
   - 해당 레코드의 잠금 해제, 다른 유저들이 다룰 수 있음.
   - 세이브 포인트가 삭제.
 ⑦ 롤백 후
   - 데이터의 변경이 취소.
   - 데이터의 이전 상태가 회복.
   - 데이터에 대한 잠금이 해제.

11. DBMS
  - Database Management System, 데이터베이스 매니저먼트 시스템, 응용프로그램이 데이터에 대한 액세스가 가능하도록 DB를 관리하는 소프트웨어 기능, 데이터가 저장되어 있는 장소.


12. RDBMS
  - 관계형 데이터베이스 관리시스템, 일반적으로 관계형 데이터 모델에 기반한 데이터베이스를 관계형 데이터 베이스라고 함.
  - 특징 : 데이터를 테이블로 표현하고 테이블을 집합으로 받아들임.
             데이터를 조작하는 데는 집합론에 기초한 수학적인 연산을 테이블에 대해 실행.


12. DB정규화의 목적
   - 자료정규화 작업의 가장 큰 목적은 자료저장의 중복성 배제이다. 정규화이론에서는 릴레이션의 형태가 여러단계로 구분되며, 가장 기본적인 정규화조건도 만족하지 못하는 릴레이션을 비정규형, 만족하는 릴레이션을 제1정규형이라고 부름. 조건이 점점 엄격해짐에 따라 제2, 제3, 제4, 제5정규형으로 구분됨. 높은 단계의 정규형으로 나아갈수록 데이타의 본질적 의미가 릴레이션 구조에 보다 정확히 반영되고, 데이타 중복을 줄이고, 데이타 변경시 발생하는 문제점을 방지하고, 궁극적으로 데이타 무결성(data integrity)을 제고할 수 있다고 가정함. 


13. ACID (Atomic Consistent Isolated Durable)
- 원자성, 일관성, 독립성, 지속성의 약어.
  데이터베이스 트랜젝션이 안전하게 수행된다는 것을 보장하기 위한 성질.


14. DDL (Data Definition Language)
   테이블 및 객체의 구조 생성 그리고 삭제, 변경과 관련된 명령어.
  - CRATE : 새로운 테이블 생성.
  - DROP : 기존 테이블의 구조 및 모든 행을 삭제.
  - ALTER : 기존 테이블 변경, 필드를 추가 또는 수정 할 수 있지만 삭제 불가. 
  - TRUNCATE : 테이블의 구조를 남기고 모든 데이터 삭제.
  - RENAME : 오브젝트의 이름을 변경.
  - COMMENT : 테이블이나 컬럼에 주석문.


15. DML (Data Manipulation Language)
   데이터 조작과 관계된 명령어. 데이터의 검색 및 출력, 정렬과 조인에 관계 됨.
  - SELECT : 데이터의 조회.                  - INSERT : 데이터의 입력.
  - UPDATE : 데이터의 수정.                 - DELETE : 데이터의 삭제.
  - WHERE : 데이터의 조건.
  - COMMIT : 수행한 데이터 작업들의 영구 저장.
  - ROLLBACK : 수행한 데이터 작업들의 원상복구.


16. DCL (Data Control Language)
  - 계정의 권한과 관계된 명령어.
  - DB 사용자의 권한 정의.
    COMMIT : 데이터베이스 조작을 영구적으로 반영.
    ROLLBACK : 마지막 COMMIT 상태로 복구.
    GRANT : 권한 부여.
    REVOKE : 권한 취소.


■ AJAX(Asynchronous JavaScript and XML)
    - AJAX는 비동기식으로 Javascript를 이용해 클라이언트 측에서 페이지 리로딩 없이 필요한 데이터를 얻어내는 기법을 말한다. 페이지 이동 없이 화면을 전환할 수 있으며 서버 처리를 기다리지 않고 비동기 요청이 가능하다. 수신하는 데이터량을 줄일 수 있고, 클라이언트에게 처리를 위임할 수도 있다는 장점이 있다.

   - 특징 : 필요한 데이터만 서버로 보내고 해당 정보만 받음.
             서버로부터 정보를 받을때는 xml 이나 json 형태로 받고 클라이언트에서는 그 정보들을 DOM을 통해 화면을 재가공 하여 보여주기 때문에, 서버와 교환되는 데이터의 양이 적어지므로 점유율을 낮출 수 있음. 클라이언트에서 데이터를 처리하므로 서버에 부담이 덜 가기 때문에 다른 응답요청에 신속히 응대 할 수 있음.


■ 기타
  ο http와 https
    - http
      인터넷에서 하이퍼텍스트(hypertext) 문서를 교환하기 위하여 사용되는 통신규약이다. 하이퍼텍스트는 문서 중간중간에 특정 키워드를 두고 문자나 그림을 상호 유기적으로 결합하여 연결시킴으로써, 서로 다른 문서라 할지라도 하나의 문서인 것처럼 보이면서 참조하기 쉽도록 하는 방식을 의미한다.

    - https
      https란 인터넷 상에서 정보를 암호화하는 SSL(Secure Socket Layer) 프로토콜을 이용하여 데이터를 전송하고 있다는 것을 의미한다. SSL 프로토콜은 테리사(Terrsa)가 개발해 Netscape사가 NetSite의 암호화 중심 프로토콜로 정착시킨 기술로 정보 암호화시 공개키(Pubilc Key)와 개인키(Private Key)라는 두가지 키를 이용하는 방법이다.
      공개키(Public Key)는 인터넷 상에 공개되어 있는 키로 서버에서 자동으로 이용자님의 브라우져로 보내며, 이용자가 입력한 정보는 이 공개키(Public Key)를 이용하여 암호화되어 다시 서버까지 전달된다. 
      이 공개키(Public Key)로 암호화된 정보는 서버만이 유일하게 소유하고 있는 개인키(Private Key)로만 해독이 가능하다.
      제3자가 의도적으로 암호화된 이용자 정보를 가로챈다 하더라도, 서버의 개인키(Private Key)가 없는 한은 해석이 불가능하다.


  ο  ERD란?
     Entity Relationship Diagram의 약자로 개체관계도. 말로서 되어있는 요구분석사항을 그림으로 그려내어 그 관계를 도출하는 것.


  ο  ERP(Enterprise Resource Planning)
    ① 전산적 자원 관리 시스템.
    ② 기업의 모든 자원을 전체적으로 관리하여 최적화된 기업 활동을 통합, 관리 시스템에 근거하여 스피드 경영과 투명 경영의 효과를 꾀하는 것.


  ο  OSI 7 Layers (OSI 7계층 구조)
   - 7계층: 응용 계층 (application layer)
   - 6계층: 표현 계층(presentation layer)
   - 5계층: 세션 계층(session layer)
   - 4계층: 전송 계층(transport layer)
   - 3계층: 네트워크 계층(network layer)
   - 2계층: 데이터링크 계층(data link layer)
   - 1계층: 물리 계층(physical layer)

  ① 개요
    컴퓨터 통신 분야에서 동일 업체 또는 유사 업체끼리의 다양한 표준들이 양산됨에 따라 표준을 정의하는 골격으로서의 국제적인 기준 모델이 필요하게 되었다. 따라서 네트워크 상호간의 접속을 목적으로 각종 규격 개발적업을 조정하기 위한 공통 기반을 제공하고 각 사업자별로 개발된 기존 규격에 대하여는 이러한 참조 모델에 쉽게 적응 연결토록 하는 편의성을 제공하고자 했다.

  ② 표준화를 위한 기본 골격
    IOS의 개방형 시스템간 상호 접속 모델(Open System Interconnection model)은 각 계층에서 표준이 개발, 발전될수 있도록 기본들을 제공하며 프로토콜의 발전을 유도, 인도하는데 그 목적이 있다, 결론적으로 OSI 참조모델은 참조모델이라기 보다는 표준의 표준으로써 다만 표준화를 유도하기 위한 기본 골격에 불과하는 것이다.

  ③ 계층간독립성
    각 계층별로 독립시킨다는 것은 융통성(flexibiltty)을 부여하게 된다.
예를 들면 보다 좋은 성능을 가진 전기적 인터페이스가 개발되면 상위계층에게 영향을 미치지 않고 성능을 향상시킨 채 교체가 가능하기 때문이다.

  ④ 계층내 프로토콜
    OSI가 각 계층별로 하나의 프로토콜만이 존재하는 그릇된 생각을 할수 있는데 이는 잘못된 생각이며 사실 각 층을 구현하기 위한 다양한 프로토콜이 존재한다. 그러나 같은 계층에 있는 여러 다른 기능의 프로토콜은 바로 하위 계층에서 제공하는 서비스를 공유하여야 한다.

  ⑤ 연결 지향성 및 비연결성 
    OSI는 초기에는 연결 지향성 서비스 위주의 프로토콜들에만 관심을 가져왔으나 후에 비연결성에도 관심을 가지게 되었다.


  ο  Stack 과 Queue
    ① Stack : 
     모든 작업이 리스트의 한쪽 끝에서만 수행되는 선형 리스트의 한 형태로, 리스트의 한쪽 끝(TOP)에서 원소를 삽입하거나 제거하는데 사용. 그러므로 리스트에서 스택에 마지막으로 입력된 원소가 제일 먼저 제거의 대상이 됨. 그래서 스택을 LIFO (Last In First Out) 라고도 함. 
   ② Queue방식 : 
      삽입은 REAR에서 이루어지고, 제거는 FRONT에서 이루어짐. 큐에 A, B, C, D, E순으로 원소가 삽입되었다면, 제일 먼저 제거되는 원소는 A. Q는 FIFO(First In First Out)라고 함.

